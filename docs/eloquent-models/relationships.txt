.. _laravel-eloquent-model-relationships:

============================
Eloquent Model Relationships
============================

.. facet::
   :name: genre
   :values: tutorial

.. meta::
   :keywords: php framework, odm, code example

Relationships
-------------

Basic Usage
~~~~~~~~~~~

The only available relationships are:


* hasOne
* hasMany
* belongsTo
* belongsToMany

The MongoDB-specific relationships are:


* embedsOne
* embedsMany

Here is a small example:

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class User extends Model
   {
       public function items()
       {
           return $this->hasMany(Item::class);
       }
   }

The inverse relation of ``hasMany`` is ``belongsTo``:

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class Item extends Model
   {
       public function user()
       {
           return $this->belongsTo(User::class);
       }
   }

belongsToMany and pivots
~~~~~~~~~~~~~~~~~~~~~~~~

The belongsToMany relation will not use a pivot "table" but will push id's to
a **related_ids** attribute instead. This makes the second parameter for the
belongsToMany method useless.

If you want to define custom keys for your relation, set it to ``null``:

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class User extends Model
   {
       public function groups()
       {
           return $this->belongsToMany(
               Group::class, null, 'user_ids', 'group_ids'
           );
       }
   }

EmbedsMany Relationship
~~~~~~~~~~~~~~~~~~~~~~~

If you want to embed models, rather than referencing them, you can use the
``embedsMany`` relation. This relation is similar to the ``hasMany`` relation
but embeds the models inside the parent object.

**REMEMBER**\ : These relations return Eloquent collections, they don't return
query builder objects!

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class User extends Model
   {
       public function books()
       {
           return $this->embedsMany(Book::class);
       }
   }

You can access the embedded models through the dynamic property:

.. code-block:: php

   $user = User::first();

   foreach ($user->books as $book) {
       //
   }

The inverse relation is auto *magically* available. You can omit the reverse
relation definition.

.. code-block:: php

   $book = Book::first();

   $user = $book->user;

Inserting and updating embedded models works similar to the ``hasMany`` relation:

.. code-block:: php

   $book = $user->books()->save(
       new Book(['title' => 'A Game of Thrones'])
   );

   // or
   $book =
       $user->books()
            ->create(['title' => 'A Game of Thrones']);

You can update embedded models using their ``save`` method (available since
release 2.0.0):

.. code-block:: php

   $book = $user->books()->first();

   $book->title = 'A Game of Thrones';
   $book->save();

You can remove an embedded model by using the ``destroy`` method on the
relation, or the ``delete`` method on the model (available since release 2.0.0):

.. code-block:: php

   $book->delete();

   // Similar operation
   $user->books()->destroy($book);

If you want to add or remove an embedded model, without touching the database,
you can use the ``associate`` and ``dissociate`` methods.

To eventually write the changes to the database, save the parent object:

.. code-block:: php

   $user->books()->associate($book);
   $user->save();

Like other relations, embedsMany assumes the local key of the relationship
based on the model name. You can override the default local key by passing a
second argument to the embedsMany method:

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class User extends Model
   {
       public function books()
       {
           return $this->embedsMany(Book::class, 'local_key');
       }
   }

Embedded relations will return a Collection of embedded items instead of a
query builder. Check out the available operations here:
`https://laravel.com/docs/master/collections <https://laravel.com/docs/master/collections>`__

EmbedsOne Relationship
~~~~~~~~~~~~~~~~~~~~~~

The embedsOne relation is similar to the embedsMany relation, but only embeds a single model.

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class Book extends Model
   {
       public function author()
       {
           return $this->embedsOne(Author::class);
       }
   }

You can access the embedded models through the dynamic property:

.. code-block:: php

   $book = Book::first();
   $author = $book->author;

Inserting and updating embedded models works similar to the ``hasOne`` relation:

.. code-block:: php

   $author = $book->author()->save(
       new Author(['name' => 'John Doe'])
   );

   // Similar
   $author =
       $book->author()
            ->create(['name' => 'John Doe']);

You can update the embedded model using the ``save`` method (available since 
release 2.0.0):

.. code-block:: php

   $author = $book->author;

   $author->name = 'Jane Doe';
   $author->save();

You can replace the embedded model with a new model like this:

.. code-block:: php

   $newAuthor = new Author(['name' => 'Jane Doe']);

   $book->author()->save($newAuthor);

Cross-Database Relationships
----------------------------

If you're using a hybrid MongoDB and SQL setup, you can define relationships 
across them.

The model will automatically return a MongoDB-related or SQL-related relation 
based on the type of the related model.

If you want this functionality to work both ways, your SQL-models will need 
to use the ``MongoDB\Laravel\Eloquent\HybridRelations`` trait.

**This functionality only works for ``hasOne``, ``hasMany`` and ``belongsTo``.**

The SQL model must use the ``HybridRelations`` trait:

.. code-block:: php

   use MongoDB\Laravel\Eloquent\HybridRelations;

   class User extends Model
   {
       use HybridRelations;

       protected $connection = 'mysql';

       public function messages()
       {
           return $this->hasMany(Message::class);
       }
   }

Within your MongoDB model, you must define the following relationship:

.. code-block:: php

   use MongoDB\Laravel\Eloquent\Model;

   class Message extends Model
   {
       protected $connection = 'mongodb';

       public function user()
       {
           return $this->belongsTo(User::class);
       }
   }
